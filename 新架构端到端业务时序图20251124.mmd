sequenceDiagram
    autonumber
    actor User as User (用户)
    participant Server as Server (Web/Worker)
    participant Redis as Redis (Cache/Queue)
    participant MySQL as MySQL (DB)
    participant AI as AI API (VolcEngine)

    Note over User, MySQL: === 1. 用户登录与初始化 ===
    User->>Server: 访问主页 / 登录 (Login)
    Server->>Redis: GET user:{uid}:info (尝试读取用户信息缓存)
    alt Redis缓存未命中 (Cache Miss)
        Server->>MySQL: SELECT * FROM user_info WHERE username=...
        MySQL-->>Server: 返回用户信息
        Server->>Redis: SET user:{uid}:info (写入用户信息, TTL 8h)
        Server->>Redis: SET user:{uid}:balance (写入余额, TTL 8h)
    else Redis缓存命中 (Cache Hit)
        Redis-->>Server: 返回用户信息
    end
    Server-->>User: 登录成功 (返回Token)

    Note over User, MySQL: === 2. 加载主页数据 ===
    User->>Server: 获取主页数据 (历史记录, 余额, 标签)
    par 获取余额
        Server->>Redis: GET user:{uid}:balance
    and 获取历史记录
        Server->>Redis: ZREVRANGE user:{uid}:history (获取最近任务ID)
        Server->>Redis: HGETALL query:{uid}:{qid}:info (获取任务详情)
    and 获取学科标签
        Server->>Redis: HGETALL sys:tags:info (获取标签列表)
    end
    Server-->>User: 返回主页渲染数据

    Note over User, MySQL: === 3. 提交查询任务 (Query) ===
    User->>Server: 选择标签 -> 获取期刊列表
    Server->>Redis: SMEMBERS sys:tag_journals:{Tag} (根据标签查期刊)
    Redis-->>Server: 返回期刊列表
    Server-->>User: 展示期刊列表

    User->>Server: 选中期刊 + 年份范围 -> 点击"更新统计"
    Server->>Redis: HGET sys:journals:price (获取单价)
    Server->>Redis: HGET contentlist_year_number {JournalName} (获取该刊各年份文献数)
    Server-->>User: 返回估算费用与文献总数

    User->>Server: 点击"开始检索" (Submit Query)
    Server->>Redis: HSET query:{uid}:{qid}:status (初始化任务状态, total_blocks)
    Server->>Redis: RPUSH task:{uid}:{qid}:pending_blocks (将任务拆解为Block Keys入队)
    Note right of Server: Block Key 示例: meta:NATURE:2024
    
    Server->>Server: 检查用户Permission -> 启动对应数量 Worker线程

    Note over Server, AI: === 4. 任务执行循环 (Worker Threads) ===
    loop Every Worker Thread
        Server->>Redis: LPOP task:{uid}:{qid}:pending_blocks (抢占任务Block)
        
        alt 队列为空
            Server->>Server: Worker线程退出
        else 成功取到 Block Key
            Server->>Redis: GET query:{uid}:{qid}:pause_signal (检查暂停信号)
            alt 收到暂停信号
                Server->>Redis: LPUSH task:{uid}:{qid}:pending_blocks (任务回退到队列头)
                Server->>Server: Worker线程立即销毁
            else 正常执行
                Server->>Redis: HGETALL {BlockKey} (一次性拉取该年份所有文献DOI和压缩Bib)
                Redis-->>Server: 返回 DOIs + Bib Strings
                
                loop Block内每一篇文献
                    Server->>Server: 解析 Bib -> 提取摘要 -> 构造 Prompt
                    Server->>AI: 发送请求 (Chat Completion)
                    AI-->>Server: 返回分析结果 + Token Usage
                    
                    Server->>Server: 累加 Token 到 TPM统计器
                    
                    Server->>Redis: GET user:{uid}:balance (检查余额)
                    alt 余额充足
                        Server->>Redis: DECRBY user:{uid}:balance (原子扣费)
                        Server->>Redis: HSET result:{uid}:{qid} (存储AI结果)
                        Server->>Redis: RPUSH billing_queue:{uid} (写入流水队列, 用于异步对账)
                        Server->>Redis: HINCRBY progress:{uid}:{qid}:finished_count (更新进度条)
                    else 余额不足
                        Server->>Server: 标记跳过/失败
                    end
                end

                Server->>Redis: HINCRBY query:{uid}:{qid}:status finished_blocks 1 (Block完成计数)
                
                Server->>Redis: HGET query:{uid}:{qid}:status
                alt finished_blocks == total_blocks (任务全部完成)
                    Server->>Redis: HSET query:{uid}:{qid}:status state=DONE
                    Server->>Server: 触发结果归档 (Redis -> MySQL)
                end
            end
        end
    end

    Note over Server, MySQL: === 5. 计费同步 (Billing Sync) ===
    loop 后台 BillingSyncer 线程
        Server->>Redis: LPOP billing_queue:{uid} (批量取出消费流水)
        Server->>MySQL: UPDATE user_info SET balance = balance - total WHERE uid=... (批量更新数据库)
    end

    Note over User, AI: === 6. 蒸馏任务 (Distillation) ===
    User->>Server: 对任务QID发起"蒸馏" (Distill)
    Server->>Redis: HGETALL result:{uid}:{parent_qid} (读取父任务结果)
    Server->>Server: 筛选"相符"文献 -> 生成 Chunk Keys
    Server->>Redis: RPUSH task:{uid}:{new_qid}:pending_blocks (推入新任务队列)
    Server->>Server: 启动 Worker
    
    loop Distill Worker
        Server->>Redis: LPOP task (取 Chunk)
        Server->>Redis: HGET result:{uid}:{parent_qid} (查父结果找BlockKey)
        Server->>Redis: HGET {BlockKey} (获取原始 Bib/Abstract)
        Server->>AI: 发送蒸馏 Prompt
        AI-->>Server: 返回深度分析
        Server->>Redis: 存结果 + 扣费 (0.1倍费率)
    end

    Note over User, Server: === 7. 结果下载 (异步队列模式) ===
    User->>Server: 点击"下载CSV" / "下载Bib"
    Server->>Redis: 创建任务 HSET download:{task_id}:status (state=PENDING)
    Server->>Redis: RPUSH download_queue {task_id, uid, qid, type}
    Server-->>User: 立即返回 task_id (<100ms)
    
    par 前端轮询状态
        loop 每秒轮询
            User->>Server: GET /api/download/status?task_id=xxx
            Server->>Redis: HGET download:{task_id}:status
            Redis-->>Server: 返回状态 (PENDING/PROCESSING/READY)
            Server-->>User: 返回当前状态
        end
    and DownloadWorker处理 (10个Worker并发)
        loop DownloadWorker Pool
            Server->>Redis: LPOP download_queue (抢占任务)
            Server->>Redis: HSET download:{task_id}:status state=PROCESSING
            Server->>Redis: HGETALL result:{uid}:{qid} (获取AI结果)
            Note right of Server: Pipeline批量获取优化
            Server->>Redis: Pipeline HGETALL {BlockKey1}, HGETALL {BlockKey2}... (批量获取Bib)
            Redis-->>Server: 返回所有Bib数据 (O(1)网络往返)
            Server->>Server: 内存生成 CSV / Bib 文件
            Server->>Redis: SET download:{task_id}:file (存储文件, TTL 5分钟)
            Server->>Redis: HSET download:{task_id}:status state=READY
        end
    end
    
    User->>Server: GET /api/download/file?task_id=xxx (状态为READY后)
    Server->>Redis: GET download:{task_id}:file
    Server-->>User: 返回文件流 (Content-Disposition)
